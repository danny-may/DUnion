using DUnion.Models;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CA = Microsoft.CodeAnalysis;

namespace DUnion;

internal static class Helpers
{
    private static readonly Regex _disallowedChars = new(@"[<>]", RegexOptions.Compiled);

    public static IEnumerable<CA.INamedTypeSymbol> ContainingTypes(this CA.ISymbol symbol)
    {
        for (var container = symbol.ContainingType; container is not null; container = container.ContainingType)
        {
            yield return container;
        }
    }

    public static string FileName(TypeId id)
    {
        return _disallowedChars.Replace(
            Render(id),
            match => match.Value switch
            {
                "<" => "[",
                ">" => "]",
                _ => "_"
            });
    }

    public static string GetNamespace(this CA.ISymbol symbol)
    {
        var namespaceStack = new List<CA.INamespaceSymbol>();
        for (var current = symbol.ContainingNamespace; current is not null; current = current.ContainingNamespace)
            namespaceStack.Add(current);
        var @namespace = string.Join(".", namespaceStack.Select(n => n.Name).Where(n => n.Length > 0).Reverse());
        return @namespace;
    }

    public static bool IsUnionCase(CA.ISymbol symbol)
    {
        return symbol is CA.INamedTypeSymbol
            && symbol.ContainingType is not null
            && symbol.ContainingType.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == Constants.DUnionAttribute);
    }

    public static string Render(TypeId id)
    {
        var result = id.Containers
            .Select(c => c.Name + Render(c.TypeParameters))
            .Append(id.Name + Render(id.TypeParameters));
        if (id.Namespace is { Length: > 0 })
            result = result.Prepend(id.Namespace);
        return string.Join(".", result);
    }

    public static string Render(Sequence<TypeParameter> typeParameters)
    {
        return typeParameters.Length == 0 ? ""
            : $"<{string.Join(", ", typeParameters.Select(p => p.Name))}>";
    }

    public static string RenderDocSee(TypeId id)
    {
        return $"<see cref=\"{Render(id).Replace('<', '{').Replace('>', '}')}\" />";
    }

    public static string ToFullName(TypeId id)
    {
        var result = id.Containers
            .Select(c => c.Name + Render(c.TypeParameters))
            .Append(id.Name + Render(id.TypeParameters));
        if (id.Namespace is { Length: > 0 })
            result = result.Prepend(id.Namespace);
        return string.Join(".", result);

        static string Render(Sequence<TypeParameter> typeParameters)
            => typeParameters.Length == 0 ? "" : $"`{typeParameters.Length}";
    }

    public static string ToFullSignature(this CA.INamedTypeSymbol symbol)
    {
        var result = new StringBuilder();
        result.Append(symbol.GetNamespace());
        foreach (var container in symbol.ContainingTypes().Reverse())
        {
            result.Append(".");
            ToSignature(container, result);
        }
        result.Append(".");
        ToSignature(symbol, result);
        return result.ToString().TrimStart('.');
    }

    public static Sequence<T> ToSequence<T>(this IEnumerable<T> source)
    {
        return new(source);
    }

    public static string ToSignature(this CA.INamedTypeSymbol symbol)
    {
        var result = new StringBuilder();
        ToSignature(symbol, result);
        return result.ToString();
    }

    public static SourceText ToSourceText(string content)
    {
        return SourceText.From(Constants.AutoGeneratedHeader + content, Encoding.UTF8);
    }

    private static void ToSignature(CA.INamedTypeSymbol symbol, StringBuilder result)
    {
        result.Append(symbol.Name);
        if (symbol.TypeParameters is { Length: > 0 })
        {
            result.Append("<");
            result.Append(symbol.TypeParameters[0].Name);
            foreach (var parameter in symbol.TypeParameters.Skip(1))
            {
                result.Append(",");
                result.Append(parameter.Name);
            }
            result.Append(">");
        }
    }
}